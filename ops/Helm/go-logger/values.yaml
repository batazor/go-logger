deployment:
  replicaCount: 1

  podDisruptionBudget: {}
    # maxUnavailable: 1
    # minAvailable: 2

  securityContext:
    runAsUser: 997
    fsGroup: 997
    runAsNonRoot: true

  ## Duration in seconds the pod needs to terminate gracefully
  terminationGracePeriodSeconds: 30

  ## Deployments rolling update update strategy
  ## Ref: https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-set/#rolling-update
  ##
  updateStrategy: RollingUpdate

  ## Annotations to be added to the Service
  ##
  annotations: {}

  ## Affinity
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  affinity: {}

  ## Tolerations
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  tolerations: []

  ## Optionally specify an array of imagePullSecrets.
  ## Secrets must be manually created in the namespace.
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
  ##
  # pullSecrets:
  #   - myRegistrKeySecretName

  ## Node selector
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
  nodeSelector: {}

  image:
    repository: hub.docker.com/batazor/go-logger
    tag: latest

    ## Specify a imagePullPolicy
    ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
    ## ref: http://kubernetes.io/docs/user-guide/images/#pre-pulling-images
    ##
    pullPolicy: IfNotPresent

  env:
    GRPC_ENABLE: "true"
    GRPC_PORT: "50051"
    AMQP_ENABLE: "false"
    AMQP_API: amqp://telemetry:telemetry@localhost:5672/
    AMQP_NAME_QUEUE: go-logger-packets
    AMQP_EXCHANGE_LIST: "demo1, demo2"
    DB_URL: http://influxdb:8086
    DB_NAME: telemetry
    DB_USERNAME: telemetry
    DB_PASSWORD: telemetry
    DB_ID: _oid

  ## Configure resource requests and limits
  ## ref: http://kubernetes.io/docs/user-guide/compute-resources/
  ##
  resources:
    limits:
      cpu: 500m
      memory: 500Mi
    requests:
      cpu: 50m
      memory: 50Mi

  ## Configure extra options for liveness and readiness probes
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#configure-probes)
  livenessProbe:
    enabled: false
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5

  readinessProbe:
    enabled: false
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 1
    successThreshold: 1
    failureThreshold: 5

## Role Based Access
## Ref: https://kubernetes.io/docs/admin/authorization/rbac/
##
rbac:
  create: true

networkPolicy:
  ## Enable creation of NetworkPolicy resources.
  ##
  enabled: true

  ## The Policy model to apply. When set to false, only pods with the correct
  ## client label will have network access to the port Logger is listening
  ## on. When true, Logger will accept connections from any source
  ## (with the correct destination port).
  ##
  allowExternal: true

## Service Account
## Ref: https://kubernetes.io/docs/admin/service-accounts-admin/
##
serviceAccount:
  create: true

  ## The name of the ServiceAccount to use.
  ## If not set and create is true, a name is generated using the fullname template
  # name:

service:
  annotations: {}

  ## Kubernetes service type
  type: ClusterIP

  ## Port to expose on each node
  ## Only used if service.type is 'NodePort'
  ##
  # nodePort: 27017

prometheus:
  ## Configures Prometheus Exporter to expose and scrape stats.
  exporter:
    enabled: true
    env: {}
    image:
      registry: docker.io
      repository: oliver006/logger_exporter
      tag: v0.21.0
      pullPolicy: IfNotPresent

    ## Port Prometheus scrapes for metrics
    port: 9090

    path: "/metrics"

    ## Allow overriding of container resources
    resources: {}
     # limits:
     #   cpu: 200m
     #   memory: 1Gi
     # requests:
     #   cpu: 100m
     #   memory: 100Mi

  ## Prometheus is using Operator.  Setting to true will create Operator specific resources like ServiceMonitors and Alerts
  operator:
    ## Are you using Prometheus Operator? [Blog Post](https://coreos.com/blog/the-prometheus-operator.html)
    enabled: true

    ## Configures Alerts, which will be setup via Prometheus Operator / ConfigMaps.
    alerts:
      ## Prometheus exporter must be enabled as well
      enabled: true

      ## Selector must be configured to match Prometheus Install, defaulting to whats done by Prometheus Operator
      ## See [CoreOS Prometheus Chart](https://github.com/coreos/prometheus-operator/tree/master/helm)
      selector:
        role: alert-rules
      labels: {}

    serviceMonitor:
      ## Interval at which Prometheus scrapes logger Exporter
      interval: 10s

      # Namespace Prometheus is installed in
      namespace: monitoring

      ## Defaults to whats used if you follow CoreOS [Prometheus Install Instructions](https://github.com/coreos/prometheus-operator/tree/master/helm#tldr)
      ## [Prometheus Selector Label](https://github.com/coreos/prometheus-operator/blob/master/helm/prometheus/templates/prometheus.yaml#L65)
      ## [Kube Prometheus Selector Label](https://github.com/coreos/prometheus-operator/blob/master/helm/kube-prometheus/values.yaml#L298)
      selector:
        prometheus: kube-prometheus

chronograf:
  service:
    type: NodePort

influxdb:
  ## influxdb image version
  ## ref: https://hub.docker.com/r/library/influxdb/tags/
  image:
    tag: 1.6-alpine

  service:
    type: NodePort

  env:
  - name: INFLUXDB_ADMIN_ENABLED
    value: "true"
  - name: INFLUXDB_DB
    value: "telemetry"
  - name: INFLUXDB_ADMIN_USER
    value: "admin"
  - name: INFLUXDB_ADMIN_PASSWORD
    value: "admin"
  - name: INFLUXDB_USER
    value: "telemetry"
  - name: INFLUXDB_USER_PASSWORD
    value: "telemetry"
  - name: INFLUXDB_DATA_ENGINE
    value: "tsm1"
  - name: INFLUXDB_REPORTING_DISABLED
    value: "false"

  ## Change InfluxDB configuration parameters below:
  ## Defaults are indicated
  ## ref: https://docs.influxdata.com/influxdb/v1.1/administration/config/
  config: {}
#    reporting_disabled: false
#    bind_address: 8088
#    storage_directory: /var/lib/influxdb
#    meta:
#      retention_autocreate: true
#      logging_enabled: true
#    data:
#      query_log_enabled: true
#      cache_max_memory_size: 1073741824
#      cache_snapshot_memory_size: 26214400
#      cache_snapshot_write_cold_duration: 10m0s
#      compact_full_write_cold_duration: 4h0m0s
#      max_series_per_database: 1000000
#      max_values_per_tag: 100000
#      trace_logging_enabled: false
#    coordinator:
#      write_timeout: 10s
#      max_concurrent_queries: 0
#      query_timeout: 0s
#      log_queries_after: 0s
#      max_select_point: 0
#      max_select_series: 0
#      max_select_buckets: 0
#    retention:
#      enabled: true
#      check_interval: 30m0s
#    shard_precreation:
#      enabled: true
#      check_interval: 10m0s
#      advance_period: 30m0s
#    admin:
#      enabled: false
#      bind_address: 8083
#      https_enabled: false
#      https_certificate: /etc/ssl/influxdb.pem
#    monitor:
#      store_enabled: true
#      store_database: _internal
#      store_interval: 10s
#    subscriber:
#      enabled: true
#      http_timeout: 30s
#      insecure_skip_verify: false
#      ca_certs: ""
#      write_concurrency: 40
#      write_buffer_size: 1000
#    http:
#      enabled: true
#      bind_address: 8086
#      auth_enabled: false
#      log_enabled: true
#      write_tracing: false
#      pprof_enabled: true
#      https_enabled: false
#      https_certificate: /etc/ssl/influxdb.pem
#      https_private_key: ""
#      max_row_limit: 10000
#      max_connection_limit: 0
#      shared_secret: "beetlejuicebeetlejuicebeetlejuice"
#      realm: InfluxDB
#      unix_socket_enabled: false
#      bind_socket: /var/run/influxdb.sock
#    graphite:
#      enabled: false
#      bind_address: 2003
#      database: graphite
#      retention_policy: autogen
#      protocol: tcp
#      batch_size: 5000
#      batch_pending: 10
#      batch_timeout: 1s
#      consistency_level: one
#      separator: .
#      udp_read_buffer: 0
#      # Uncomment to define graphite templates
#      # templates:
#      #   - "graphite.metric.*.*.* measurement.run"
#    collectd:
#      enabled: false
#      bind_address: 25826
#      database: collectd
#      retention_policy: autogen
#      batch_size: 5000
#      batch_pending: 10
#      batch_timeout: 10s
#      read_buffer: 0
#      typesdb: /usr/share/collectd/types.db
#      security_level: none
#      auth_file: /etc/collectd/auth_file
#    opentsdb:
#      enabled: false
#      bind_address: 4242
#      database: opentsdb
#      retention_policy: autogen
#      consistency_level: one
#      tls_enabled: false
#      certificate: /etc/ssl/influxdb.pem
#      batch_size: 1000
#      batch_pending: 5
#      batch_timeout: 1s
#      log_point_errors: true
#    udp:
#      enabled: false
#      bind_address: 8089
#      database: udp
#      retention_policy: autogen
#      batch_size: 5000
#      batch_pending: 10
#      read_buffer: 0
#      batch_timeout: 1s
#      precision: "ns"
#    continuous_queries:
#      log_enabled: true
#      enabled: true
#      run_interval: 1s
